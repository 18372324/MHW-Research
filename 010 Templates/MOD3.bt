//------------------------------------------------
//--- 010 Editor v8.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: *.mod3
//  ID Bytes: 
//   History: 
//------------------------------------------------
struct Vector3{
    float x;
    float y;
    float z;
};
struct Header{
    long id<format=hex>;
    ubyte version;
    ubyte version2;
    short boneCount;
    short meshCount;
    short materialCount;
    long vertexCount;
    long faceCount;
    long vertexIds;
    long vertexBufferSize;
    long secondBufferSize;
    if(version<190){
        long textureCount;
    }
    uint64 groupCount;
    if((version<190)||(version>220)){
        uint64 boneMapCount;
    }
    uint64 boneOffset<format=hex>;
    uint64 groupOffset<format=hex>;
    uint64 textureOffset<format=hex>;
    uint64 meshOffset<format=hex>;
    uint64 VertexOffset<format=hex>;
    if(version<190){
        long vertex2Offset<format=hex>;
    }
    uint64 FacesOffset<format=hex>;
    uint64 unknOffset<format=hex>;
    if(version<190){
        long unkOffset2<format=hex>;
        Vector3 bbsphereposition;
        float bspereradius;
        Vector3 bbmin;
        long unkn;
        Vector3 bbmax;
        long unkn;
        
    }
};
struct MeshPartV3{
    short unkn;
    short VertexCount;
    short materialIdx;
    short unkn;
    long lod;
    short unkn2;
    byte blockSize;
    byte unkn3;
    long VertexSub;
    long VertexOffset;
    long blocktype <format=hex>;
    long FaceOffset;
    long FaceCount;
    long vertexBase;
    ubyte bonremapid;
    ubyte unkn7[3];
    ubyte unkn8;
    ubyte unkn9[35];
};
struct Face{
    short v1;
    short v2;
    short v3;
};
struct MODVertexBufferf637401c{
    float x;
    float y;
    float z;
    ubyte u1;
    ubyte u2;
    ubyte u3;
    ubyte u4;
    long u5;
    short u6;
    short u7;
    long u8;


    ubyte u9;
    ubyte u10;
    ubyte u11;
    ubyte u12;
};
struct MODVertexBuffer3c730760{
    float x;
    float y;
    float z;
    ubyte u1;
    ubyte u2;
    ubyte u3;
    ubyte u4;
    long u5;
    short u6;
    short u7;
    long u8;


    ubyte u9;
    ubyte u10;
    ubyte u11;
    ubyte u12;
    //ubyte u13;

};
struct Faces (int i){
    local int meshPartIdx = i;
    Face faces[meshPart[i].FaceCount/3];
};
struct Vertexes3c730760 (int i){
    local int meshPartIdx = i;
    MODVertexBuffer3c730760 vertexes[meshPart[i].VertexCount];
};
struct Vertexesf637401c(int i){
    local int meshPartIdx = i;
    MODVertexBufferf637401c vertexes[meshPart[i].VertexCount];
};
Header head;
FSeek(head.meshOffset);
 local int BOFF = 0;
if(head.version==237){
    MeshPartV3 meshPart[head.meshCount];
    local int i=0;
    for(i=0;i<head.meshCount;i++){
        if(meshPart[i].blocktype==0xf637401c){
            if(meshPart[i].VertexCount>0){
                BOFF=meshPart[i].VertexSub+meshPart[i].vertexBase;
                FSeek(head.VertexOffset+meshPart[i].VertexOffset+meshPart[i].blockSize*BOFF);
                Vertexesf637401c vertexes(i);
            }
        }else if(meshPart[i].blocktype==0x3c730760){
            if(meshPart[i].VertexCount>0){
                BOFF=meshPart[i].VertexSub+meshPart[i].vertexBase;
                FSeek(head.VertexOffset+meshPart[i].VertexOffset+meshPart[i].blockSize*BOFF);
                Vertexes3c730760 vertexes(i);
            }
        }else{
            local int unknBlockType = i;
        }
    }
    for(i=0;i<head.meshCount;i++){
        if(meshPart[i].FaceCount>0){
            FSeek(head.FacesOffset+meshPart[i].FaceOffset*2);
            Faces faces(i);
        }
    }
}
